<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CommsOne — Voice + Video + Chat (WebRTC + Firebase)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root{--bg:#071028;--card:#0b1624;--accent:#2563eb;--muted:#9aa9c0;color-scheme:dark}
  *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto}
  body{margin:0;background:linear-gradient(180deg,#041226,#07102a);min-height:100vh;color:#e7f0fb;display:flex;align-items:center;justify-content:center;padding:20px}
  .app{width:1100px;max-width:100%;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03);display:grid;grid-template-columns:2fr 1fr;gap:12px;box-shadow:0 10px 40px rgba(2,6,23,0.6)}
  header{grid-column:1 / -1;display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
  .title{font-weight:700;font-size:18px}
  .sub{font-size:12px;color:var(--muted)}
  .left, .right{display:flex;flex-direction:column;gap:8px}
  /* video area */
  .video-area{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:10px;padding:10px;border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px}
  .videos{display:flex;gap:8px;align-items:center;justify-content:space-between}
  video{background:#000;border-radius:8px;width:100%;height:320px;object-fit:cover;border:1px solid rgba(255,255,255,0.03)}
  .mini{width:160px;height:120px;position:relative}
  .controls{display:flex;gap:8px;align-items:center}
  button{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:white;font-weight:600;cursor:pointer}
  .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .danger{background:#ef4444}
  .muted{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03)}
  input[type="text"]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;width:100%}
  .card{background:rgba(255,255,255,0.01);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
  /* chat */
  .chat-area{display:flex;flex-direction:column;gap:8px;height:560px}
  .messages{flex:1;overflow:auto;padding:8px;display:flex;flex-direction:column;gap:8px;border-radius:8px;background:rgba(0,0,0,0.1)}
  .msg{max-width:86%;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02)}
  .msg.me{margin-left:auto;background:linear-gradient(90deg,#10366c,#1655d6);color:white}
  .meta{font-size:11px;color:var(--muted);margin-top:6px}
  .compose{display:flex;gap:8px;align-items:center}
  .tiny{font-size:12px;color:var(--muted)}
  .presence{display:flex;gap:8px;align-items:center}
  .badge{padding:6px 8px;border-radius:20px;background:rgba(255,255,255,0.03);font-size:12px}
  .top-row{display:flex;gap:8px;align-items:center;justify-content:space-between}
  .log{font-family:monospace;font-size:12px;padding:8px;background:rgba(0,0,0,0.15);border-radius:8px;height:80px;overflow:auto}
  footer{grid-column:1 / -1;text-align:right;font-size:12px;color:var(--muted);margin-top:4px}
  @media (max-width:1000px){.app{grid-template-columns:1fr;}.videos{flex-direction:column}.mini{width:100%;height:160px}}
</style>
</head>
<body>
  <div class="app" role="application" aria-label="CommsOne">
    <header>
      <div>
        <div class="title">CommsOne — Voice · Video · Chat</div>
        <div class="sub">WebRTC peer-to-peer calls with Firebase signaling & realtime chat</div>
      </div>
      <div class="presence">
        <div class="tiny">You: <span id="meLabel">—</span></div>
        <div class="badge" id="presenceBadge">Offline</div>
      </div>
    </header>

    <div class="left">
      <div class="card video-area">
        <div class="top-row">
          <div style="display:flex;gap:8px;align-items:center">
            <input id="roomInput" type="text" placeholder="room-abc123" style="width:220px"/>
            <button id="createRoomBtn" class="btn-ghost">Create Room</button>
            <button id="joinRoomBtn" class="btn-ghost">Join Room</button>
            <button id="leaveRoomBtn" class="muted">Leave</button>
            <div class="tiny" id="roomLabel">Not in room</div>
          </div>

          <div style="display:flex;gap:8px;align-items:center">
            <div class="tiny">Call:</div>
            <div id="callState" class="badge">idle</div>
            <div class="tiny">Timer: <span id="callTimer">00:00</span></div>
          </div>
        </div>

        <div class="videos" style="margin-top:8px">
          <video id="remoteVideo" autoplay playsinline></video>
          <div style="display:flex;flex-direction:column;gap:8px;min-width:180px">
            <video id="localVideo" autoplay muted playsinline class="mini"></video>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="toggleAudioBtn" class="btn-ghost">Mute</button>
              <button id="toggleVideoBtn" class="btn-ghost">Video Off</button>
              <button id="swapCamBtn" class="btn-ghost">Switch Cam</button>
              <button id="hangupBtn" class="danger">Hang Up</button>
              <button id="startCallBtn" class="btn-ghost">Start Call</button>
            </div>
          </div>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <div class="tiny">Mic:</div><select id="audioSource"></select>
          <div class="tiny">Camera:</div><select id="videoSource"></select>
          <div style="margin-left:auto" class="tiny">ICE: <span id="iceState">new</span></div>
        </div>
      </div>

      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="tiny">Logs</div>
          <div class="tiny">Connection: <span id="pcState">new</span></div>
        </div>
        <div id="logBox" class="log"></div>
      </div>
    </div>

    <div class="right">
      <div class="card chat-area">
        <div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Chat</strong> <span class="tiny"> (room chat)</span></div>
            <div class="tiny" id="typingIndicator"></div>
          </div>
        </div>

        <div id="messages" class="messages" aria-live="polite"></div>

        <div class="compose">
          <input id="msgInput" type="text" placeholder="Write a message..." />
          <button id="sendBtn">Send</button>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="tiny">Tip: open this page on two devices and use same room ID.</div>
          <div style="display:flex;gap:8px;align-items:center">
            <div class="tiny">Online:<span id="onlineCount">0</span></div>
            <button id="copyRoomBtn" class="btn-ghost">Copy Room ID</button>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="tiny">Settings / Info</div>
        <div style="margin-top:8px">
          <div class="tiny">Replace the placeholder firebaseConfig in the script with your project's config.</div>
          <div style="margin-top:8px"><strong>TURN:</strong> add TURN servers to <code>rtcConfig.iceServers</code> for production.</div>
        </div>
      </div>
    </div>

    <footer>Built with WebRTC · Firebase Realtime Database · No external frameworks</footer>
  </div>

<script type="module">
/* =========================
  CommsOne — Single file app
  Requirements: Replace firebaseConfig below with your project's config.
  ========================= */

/* ------------------ Firebase modular imports (v9+) ------------------ */
import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
import {
  getDatabase, ref, onValue, onChildAdded, push, set, remove, update, get, child, serverTimestamp
} from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js';

/* ------------------ REPLACE WITH YOUR FIREBASE CONFIG ------------------ */
const firebaseConfig = {

  apiKey: "AIzaSyDNjcGQqerS32qGVd9tvb3DCroYEUXZ1Jo",
  authDomain: "voice-call-dcf2d.firebaseapp.com",
  databaseURL: "https://voice-call-dcf2d-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "voice-call-dcf2d",
  storageBucket: "voice-call-dcf2d.firebasestorage.app",
  messagingSenderId: "10540634677",
  appId: "1:10540634677:web:a07362297b860dfe9f977c"
    };

if (!firebaseConfig || !firebaseConfig.apiKey) {
  alert('Please replace firebaseConfig placeholder in the script with your Firebase project config.');
}

/* ------------------ Init Firebase ------------------ */
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/* ------------------ UI Elements ------------------ */
const roomInput = document.getElementById('roomInput');
const createRoomBtn = document.getElementById('createRoomBtn');
const joinRoomBtn = document.getElementById('joinRoomBtn');
const leaveRoomBtn = document.getElementById('leaveRoomBtn');
const roomLabel = document.getElementById('roomLabel');
const copyRoomBtn = document.getElementById('copyRoomBtn');

const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');
const audioSource = document.getElementById('audioSource');
const videoSource = document.getElementById('videoSource');

const startCallBtn = document.getElementById('startCallBtn');
const hangupBtn = document.getElementById('hangupBtn');
const toggleAudioBtn = document.getElementById('toggleAudioBtn');
const toggleVideoBtn = document.getElementById('toggleVideoBtn');
const swapCamBtn = document.getElementById('swapCamBtn');

const callState = document.getElementById('callState');
const callTimer = document.getElementById('callTimer');
const iceState = document.getElementById('iceState');
const pcState = document.getElementById('pcState');

const messagesEl = document.getElementById('messages');
const msgInput = document.getElementById('msgInput');
const sendBtn = document.getElementById('sendBtn');
const typingIndicator = document.getElementById('typingIndicator');
const onlineCount = document.getElementById('onlineCount');

const logBox = document.getElementById('logBox');
const meLabel = document.getElementById('meLabel');
const presenceBadge = document.getElementById('presenceBadge');

/* ------------------ Local state ------------------ */
let localStream = null;
let pc = null;
let roomId = null;
let roomRef = null;
let candidatesRef = null;
let messagesRef = null;
let presenceRef = null;
let typingRef = null;
let uid = 'u-' + Math.random().toString(36).slice(2,9);
let displayName = 'User-' + uid.slice(-4);
let isMuted = false;
let isVideoOff = false;
let callStart = null;
let callTimerInt = null;
meLabel.textContent = displayName;

/* ------------------ RTC config (add TURN servers for prod) ------------------ */
const rtcConfig = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    // Example TURN (uncomment & replace with real TURN):
    // { urls: 'turn:your.turn.server:3478', username: 'user', credential: 'pass' }
  ]
};

/* ------------------ Helpers ------------------ */
function log(...args){
  const t = new Date().toLocaleTimeString();
  logBox.textContent += `[${t}] ` + args.join(' ') + '\n';
  logBox.scrollTop = logBox.scrollHeight;
}
function setText(el, txt){ el.textContent = txt; }
function formatTime(ms){
  const s = Math.floor(ms/1000);
  return String(Math.floor(s/60)).padStart(2,'0') + ':' + String(s%60).padStart(2,'0');
}

/* ------------------ Device enumeration ------------------ */
async function enumerateMediaDevices(){
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    audioSource.innerHTML = '';
    videoSource.innerHTML = '';
    devices.forEach(d=>{
      if(d.kind === 'audioinput'){
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Microphone ${audioSource.length+1}`;
        audioSource.appendChild(opt);
      }
      if(d.kind === 'videoinput'){
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Camera ${videoSource.length+1}`;
        videoSource.appendChild(opt);
      }
    });
  }catch(e){ log('enumerate devices error', e); }
}

/* ------------------ Local media ------------------ */
async function startLocalMedia({audioDeviceId, videoDeviceId, video=true} = {}){
  try{
    if(localStream){
      localStream.getTracks().forEach(t=>t.stop());
      localStream = null;
    }
    const constraints = {
      audio: audioDeviceId ? { deviceId: { exact: audioDeviceId } } : true,
      video: video ? (videoDeviceId ? { deviceId: { exact: videoDeviceId } } : true) : false
    };
    localStream = await navigator.mediaDevices.getUserMedia(constraints);
    localVideo.srcObject = localStream;
    log('Local media started');
    await enumerateMediaDevices();
    // if peer exists, replace tracks or add tracks
    if(pc){
      const senders = pc.getSenders();
      // replace audio sender
      const audioTrack = localStream.getAudioTracks()[0];
      const videoTrack = localStream.getVideoTracks()[0];
      const senderAudio = senders.find(s => s.track && s.track.kind === 'audio');
      if(senderAudio && audioTrack) await senderAudio.replaceTrack(audioTrack);
      else if(audioTrack) pc.addTrack(audioTrack, localStream);
      const senderVideo = senders.find(s => s.track && s.track.kind === 'video');
      if(senderVideo && videoTrack) await senderVideo.replaceTrack(videoTrack);
      else if(videoTrack) pc.addTrack(videoTrack, localStream);
    }
    setText(presenceBadge, 'Online');
    updatePresence(true);
  }catch(e){ log('startLocalMedia error', e); alert('Allow camera/microphone permissions.'); }
}

/* ------------------ Peer connection ------------------ */
function createPeerConnection(){
  pc = new RTCPeerConnection(rtcConfig);
  setText(pcState, 'new');
  pc.onicecandidate = (e) => {
    if(!e.candidate) return;
    const c = e.candidate.toJSON();
    push(candidatesRef, { from: uid, candidate: c, ts: Date.now() });
    log('Local ICE candidate pushed');
  };
  pc.oniceconnectionstatechange = () => {
    setText(iceState, pc.iceConnectionState);
    setText(pcState, pc.connectionState || pc.signalingState);
    log('ICE state', pc.iceConnectionState, 'PC state', pc.connectionState);
    if(pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed'){
      setText(callState, 'connected');
      startCallTimer();
    } else if(pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed'){
      setText(callState, 'disconnected');
      stopCallTimer();
    }
  };
  pc.ontrack = (e) => {
    log('ontrack', e.streams);
    remoteVideo.srcObject = e.streams[0];
  };
  // DataChannel for optional direct data (not used for chat to keep DB canonical)
  pc.ondatachannel = (evt) => {
    log('Data channel received', evt.channel.label);
    const ch = evt.channel;
    ch.onmessage = (m) => log('DataChannel msg', m.data);
  };
  // attach local tracks
  if(localStream){
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
  }
  return pc;
}

/* ------------------ Room / Signaling helpers ------------------ */
function getRoomRef(id){
  return ref(db, 'rooms/' + id);
}
function roomPath(p){ return 'rooms/' + roomId + '/' + p; }

async function createRoom(){
  if(!roomInput.value.trim()) roomInput.value = 'room-' + Math.random().toString(36).slice(2,8);
  roomId = roomInput.value.trim();
  roomRef = getRoomRef(roomId);
  candidatesRef = ref(db, roomPath('candidates'));
  messagesRef = ref(db, roomPath('messages'));
  presenceRef = ref(db, roomPath('presence'));
  typingRef = ref(db, roomPath('typing'));
  // create peer and offer
  pc = createPeerConnection();
  // create data channel (optional)
  const dc = pc.createDataChannel('chat-channel');
  dc.onopen = () => log('Local data channel open');
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // write offer to DB
  await set(ref(db, 'rooms/' + roomId + '/signal'), {
    offer: { type: offer.type, sdp: offer.sdp },
    createdAt: Date.now(),
    creator: uid,
    creatorName: displayName
  });
  setText(roomLabel, 'Room: ' + roomId + ' (creator)');
  log('Created room and wrote offer');
  // listen for answer
  onValue(ref(db, 'rooms/' + roomId + '/signal/answer'), async (snap) => {
    const val = snap.val();
    if(val && val.sdp){
      log('Received answer from remote');
      const answerDesc = { type: val.type, sdp: val.sdp };
      await pc.setRemoteDescription(answerDesc);
    }
  });
  // listen for remote ICE candidates
  onChildAdded(candidatesRef, async (snap) => {
    const data = snap.val();
    if(!data || data.from === uid) return;
    try{
      await pc.addIceCandidate(data.candidate);
      log('Added remote ICE candidate');
    }catch(e){ log('addIceCandidate error', e); }
  });
  // start presence & message listeners
  setupChatListeners();
  // mark presence
  updatePresence(true);
}

async function joinRoom(){
  if(!roomInput.value.trim()){ alert('Enter room ID'); return; }
  roomId = roomInput.value.trim();
  roomRef = getRoomRef(roomId);
  candidatesRef = ref(db, roomPath('candidates'));
  messagesRef = ref(db, roomPath('messages'));
  presenceRef = ref(db, roomPath('presence'));
  typingRef = ref(db, roomPath('typing'));
  // get offer
  const snap = await get(ref(db, 'rooms/' + roomId + '/signal'));
  const data = snap.val();
  if(!data || !data.offer){ alert('Room not found or has no offer'); return; }
  pc = createPeerConnection();
  // set remote offer
  await pc.setRemoteDescription({ type: data.offer.type, sdp: data.offer.sdp });
  // create answer
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  // write answer
  await update(ref(db, 'rooms/' + roomId + '/signal'), {
    answer: { type: answer.type, sdp: answer.sdp, responder: uid, responderName: displayName },
    updatedAt: Date.now()
  });
  setText(roomLabel, 'Room: ' + roomId + ' (joined)');
  log('Joined room and wrote answer');
  // listen for candidates
  onChildAdded(candidatesRef, async (snap) => {
    const data = snap.val();
    if(!data || data.from === uid) return;
    try{
      await pc.addIceCandidate(data.candidate);
      log('Added remote ICE candidate');
    }catch(e){ log('addIceCandidate error', e); }
  });
  setupChatListeners();
  updatePresence(true);
}

/* ------------------ Chat (Realtime DB) ------------------ */
function setupChatListeners(){
  // messages
  onChildAdded(messagesRef, (snap) => {
    const m = snap.val();
    if(!m) return;
    renderMessage(snap.key, m);
    // auto mark seen if message from other
    if(m.sender !== uid){
      // update seen map for this message
      update(ref(db, roomPath('messages/' + snap.key + '/seen')), { [uid]: true });
    }
  });
  // online presence
  onValue(presenceRef, (snap) => {
    const val = snap.val() || {};
    const count = Object.keys(val).filter(k => val[k] === true).length;
    setText(onlineCount, count);
  });
  // typing indicator
  onValue(typingRef, (snap) => {
    const val = snap.val() || {};
    const keys = Object.keys(val).filter(k => k !== uid && val[k] === true);
    if(keys.length) setText(typingIndicator, `${keys.length} typing...`);
    else setText(typingIndicator, '');
  });
}

/* ------------------ Send Message ------------------ */
sendBtn.onclick = async () => {
  const txt = msgInput.value.trim();
  if(!txt || !messagesRef) return;
  const payload = {
    text: txt,
    sender: uid,
    senderName: displayName,
    ts: Date.now()
  };
  await push(messagesRef, payload);
  msgInput.value = '';
  // clear typing flag
  await set(ref(db, roomPath('typing/' + uid)), false);
};

/* typing indicator */
let typingTimeout = null;
msgInput.addEventListener('input', async () => {
  if(!typingRef) return;
  await set(ref(db, roomPath('typing/' + uid)), true);
  if(typingTimeout) clearTimeout(typingTimeout);
  typingTimeout = setTimeout(async () => {
    await set(ref(db, roomPath('typing/' + uid)), false);
  }, 1200);
});

/* ------------------ Render message ------------------ */
function renderMessage(key, m){
  const div = document.createElement('div');
  div.className = 'msg ' + (m.sender === uid ? 'me' : '');
  div.innerHTML = `<div>${escapeHtml(m.text)}</div>
    <div class="meta">${m.senderName || m.sender} · ${new Date(m.ts).toLocaleTimeString()}
    ${m.seen ? (' · ✓' + Object.keys(m.seen).length) : ''}</div>`;
  messagesEl.appendChild(div);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

/* ------------------ Presence ------------------ */
async function updatePresence(on){
  if(!presenceRef) return;
  await set(ref(db, roomPath('presence/' + uid)), on ? true : false);
  // remove on unload
  if(on){
    window.addEventListener('beforeunload', () => {
      set(ref(db, roomPath('presence/' + uid)), false);
    });
  }
}

/* ------------------ Call controls ------------------ */
startCallBtn.onclick = async () => {
  if(!roomId){ alert('Create or join a room first'); return; }
  if(!pc) {
    // If already have remote offer/answer handled (creator/joiner flow), pc may exist
    pc = createPeerConnection();
  }
  // if creator already created offer in createRoom flow then call proceeds automatically
  setText(callState, 'calling');
  log('Start call invoked');
};

hangupBtn.onclick = async () => {
  endCall();
  // optional clean DB room (creator might opt to remove)
  try{ await remove(ref(db, 'rooms/' + roomId)); log('Room removed from DB'); }catch(e){}
};

/* mute & video toggle */
toggleAudioBtn.onclick = () => {
  if(!localStream) return;
  isMuted = !isMuted;
  localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
  toggleAudioBtn.textContent = isMuted ? 'Unmute' : 'Mute';
};
toggleVideoBtn.onclick = () => {
  if(!localStream) return;
  isVideoOff = !isVideoOff;
  localStream.getVideoTracks().forEach(t => t.enabled = !isVideoOff);
  toggleVideoBtn.textContent = isVideoOff ? 'Video On' : 'Video Off';
};
swapCamBtn.onclick = async () => {
  // switch camera by selecting next index in videoSource
  const idx = videoSource.selectedIndex;
  const next = (idx + 1) % Math.max(1, videoSource.length);
  if(videoSource.options[next]) videoSource.selectedIndex = next;
  await startLocalMedia({ audioDeviceId: audioSource.value, videoDeviceId: videoSource.value, video: true });
};

/* hangup cleanup */
function endCall(){
  if(pc){
    pc.getSenders().forEach(s => { if(s.track) s.track.stop && s.track.stop(); });
    try{ pc.close(); }catch(e){}
    pc = null;
  }
  if(localStream){
    localStream.getTracks().forEach(t => t.stop());
    localStream = null;
    localVideo.srcObject = null;
  }
  remoteVideo.srcObject = null;
  setText(callState, 'idle');
  stopCallTimer();
  updatePresence(false);
  log('Call ended');
}

/* timer */
function startCallTimer(){
  if(callTimerInt) return;
  callStart = Date.now();
  callTimerInt = setInterval(() => {
    callTimer.textContent = formatTime(Date.now() - callStart);
  }, 500);
}
function stopCallTimer(){
  clearInterval(callTimerInt); callTimerInt = null; callTimer.textContent = '00:00';
}

/* ------------------ Utility ------------------ */
function escapeHtml(s){
  return (s + '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

/* ------------------ Room buttons wiring ------------------ */
createRoomBtn.onclick = async () => {
  await startLocalMedia({ audioDeviceId: audioSource.value, videoDeviceId: videoSource.value, video: true });
  await createRoom();
};

joinRoomBtn.onclick = async () => {
  await startLocalMedia({ audioDeviceId: audioSource.value, videoDeviceId: videoSource.value, video: true });
  await joinRoom();
};

leaveRoomBtn.onclick = async () => {
  if(!roomId) return;
  // mark presence off & detach listeners by simple reload (quick)
  try{ await set(ref(db, roomPath('presence/' + uid)), false); }catch(e){}
  endCall();
  roomId = null;
  roomInput.value = '';
  setText(roomLabel, 'Not in room');
  setText(onlineCount, '0');
  log('Left room');
};

copyRoomBtn.onclick = async () => {
  if(!roomId){ alert('No room'); return; }
  await navigator.clipboard.writeText(roomId);
  alert('Room ID copied: ' + roomId);
};

/* ------------------ Init on load ------------------ */
(async function init(){
  if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    alert('Your browser does not support WebRTC getUserMedia APIs. Use Chrome/Edge/Firefox up-to-date.');
    return;
  }
  await enumerateMediaDevices();
  // quick try to get permission so labels populate (optional)
  try {
    const s = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    s.getTracks().forEach(t=>t.stop());
    await enumerateMediaDevices();
  } catch(e){}
  log('App ready. Your uid: ' + uid + ' Name: ' + displayName);
})();
</script>
</body>
</html>

